# -*- coding: utf-8 -*-
"""Homeword_3.jipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17AVcW3HjujBEp0VhElI3qhc5jTprf3pO

Problem Set 3 - Finetune Flowers 102 - Holly Darter

Importing the neccessary libraries and modules
"""

import numpy as np
import urllib.request
from PIL import Image
from imageio import *
from skimage.transform import resize
from mpl_toolkits.axes_grid1.axes_rgb import make_rgb_axes, RGBAxes
from torchvision import models
from torchvision.models import *
from torchvision.datasets import MNIST, KMNIST, FashionMNIST
from skimage.util import montage
import skimage.io as skio
from scipy import signal
from torchvision import transforms
import requests
from torchsummary import summary
import torch
from torchvision import datasets, transforms
import os
import pandas as pd
import torch.nn.functional as F
import matplotlib.pyplot as plt
from torchvision.transforms import ToPILImage

"""Plotting a tensor using Matplotlib - moving the tensor to CPU and converting to numpy"""

def plot(x,title=None):
    x_np = x.cpu().numpy()
    if x_np.shape[0] == 3 or x_np.shape[0] == 1: # If tensor is in (C, H, W) format, transpose to (H, W, C)
        x_np = x_np.transpose(1, 2, 0)
    if x_np.shape[2] == 1: # If grayscale, squeeze the color channel
        x_np = x_np.squeeze(2)
        x_np = x_np.clip(0, 1) # Clip values to the valid range [0, 1]
        fig, ax = plt.subplots() # Create a Matplotlib figure and axis
        if len(x_np.shape) == 2:   # Display the image in grayscale or color
         im = ax.imshow(x_np, cmap='gray')
        else:
          im = ax.imshow(x_np)
        plt.title(title) # Set plot title and turn off axis ticks
        ax.axis('off')
        fig.set_size_inches(10, 10) # Set the figure size and display the plot
        plt.show()

""" Display a tensor or numpy array as a grayscale image using Matplotlib"""

def plot2(x):
    if type(x) == torch.Tensor : # Check if the input is a torch.Tensor
        x = x.cpu().detach().numpy()
    fig, ax = plt.subplots() # Create a Matplotlib figure and axis
    im = ax.imshow(x, cmap='gray')  # Display the image in grayscale
    ax.axis('off')  # Turn off axis ticks
    fig.set_size_inches(10, 10)  # Set the figure size and display the plot
    plt.show()

"""Train a PyTorch model using the specified number of epochs."""

def train_model(model, num_epochs=10):

    model = model.to(device) # Move the model to the specified device (e.g., GPU)
    criterion = torch.nn.CrossEntropyLoss() # Define the loss function (CrossEntropyLoss) and optimizer (SGD)
    optimizer = torch.optim.SGD(model.parameters(), lr=0.003, momentum=0.9)
    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)  # Learning rate scheduler with step decay
    # Training loop
    for epoch in range(num_epochs):
        print('Epoch: ',epoch+1,'/',num_epochs)
        # Train phase
        model.train()
        running_corrects = 0
        for inputs, labels in dataloaders['train']:
            inputs = inputs.to(device)
            labels = labels.to(device)
            #Print(labels)
            optimizer.zero_grad()
            outputs = model(inputs)
            preds = torch.max(outputs, 1)[1]
            running_corrects += torch.sum(preds == labels.data)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
        print("Train ", 'Acc: {:.2f}'.format(running_corrects.double()/dataset_sizes['train']))
        # Adjust learning rate based on scheduler
        scheduler.step()
         # Validation phase
        model.eval()
        running_corrects = 0
        for inputs, labels in dataloaders['valid']:
            inputs = inputs.to(device)
            labels = labels.to(device)
            outputs = model(inputs)
            preds = torch.max(outputs, 1)[1]
            running_corrects += torch.sum(preds == labels.data)
        print("Valid ", 'Acc: {:.2f}'.format(running_corrects.double()/dataset_sizes['valid']))
        print("#######################")
    return model

"""Downloading and extracting the dataset

"""

!wget https://gist.githubusercontent.com/JosephKJ/94c7728ed1a8e0cd87fe6a029769cde1/raw/403325f5110cb0f3099734c5edb9f457539c77e9/Oxford-102_Flower_dataset_labels.txt
!wget https://s3.amazonaws.com/content.udacity-data.com/courses/nd188/flower_data.zip
!unzip 'flower_data.zip' &>/dev/null

"""Directory containing the flower dataset"""

data_dir = '/content/flower_data/'

"""Mean and standard deviation for normalizing images"""

mean = np.array([0.485, 0.456, 0.406])
std = np.array([0.229, 0.224, 0.225])
preprocess = transforms.Compose([
   transforms.Resize(256),
   transforms.CenterCrop(224),
   transforms.ToTensor(),
   transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])
data_transforms = {
    'train': transforms.Compose([
        transforms.RandomResizedCrop(224),  # Data Augmentation
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize(mean, std)
    ]),
    'valid': transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean, std)
    ]),
}

"""Transform to preprocess images for model input"""

preprocess = transforms.Compose([
   transforms.Resize(256),
   transforms.CenterCrop(224),
   transforms.ToTensor(),
   transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])
data_transforms = {
    'train': transforms.Compose([
        transforms.RandomResizedCrop(224),  # Data Augmentation
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize(mean, std)
    ]),
    'valid': transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean, std)
    ]),
}

"""Data transformations for training and validation datasets"""

data_transforms = {
    'train': transforms.Compose([
        transforms.RandomResizedCrop(224),  # Data Augmentation
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize(mean, std)
    ]),
    'valid': transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean, std)
    ]),
}

"""Batch size for data loaders"""

batch_size = 16

"""Create image datasets and data loaders for training and validation"""

image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x), data_transforms[x]) for x in ['train', 'valid']}
dataloaders = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=batch_size, shuffle=True, num_workers=2) for x in ['train', 'valid']}
dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'valid']}
class_names = image_datasets['train'].classes

"""Device (GPU or CPU) for training"""

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

"""Load flower dataset labels"""

dataset_labels = pd.read_csv('Oxford-102_Flower_dataset_labels.txt', header=None)[0].str.replace("'", "").str.strip()

"""Transformation to convert tensor to PIL image"""

to_pil = ToPILImage()

"""Define the AlexNet model and move it to the specified device"""

net = models.alexnet(pretrained=True).to(device)

"""Plotting some of the images alongside their label"""

batchsz = 1
dataloader2 = torch.utils.data.DataLoader(image_datasets['train'], batch_size=batchsz, shuffle=True)
import random
for n in range(10):
  im, la = next(iter(dataloader2))
  plot(im[0],dataset_labels[int(class_names[la[0].item()])-1])

"""Showing alexnet output of images and their predicted label"""

labs = {int(key):value for (key, value) in requests.get('https://s3.amazonaws.com/mlpipes/pytorch-quick-start/labels.json').json().items()}
im, la = next(iter(dataloaders['train']))
for i in range(16):
  img = to_pil(im[i])
  img_t = preprocess(img).unsqueeze_(0).to(device)
  out = net(img_t)
  label_index = out.cpu().data.numpy().argmax()
  print('Predicted class:', labs[label_index.item()])
  out = net.features[0](img_t).cpu().detach().numpy()
  plot2(out[0,10,:,:])

"""Train the AlexNet model for the specified number of epochs"""

net = train_model(net, num_epochs=10)